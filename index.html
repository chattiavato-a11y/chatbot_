<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>OPS Online Support</title>

<meta http-equiv="Content-Security-Policy"
  content="default-src 'self';
    base-uri 'self';
    object-src 'none';
    style-src 'self' 'unsafe-inline';
    img-src 'self' data:;
    font-src 'self' data:;
    frame-src 'self' https://challenges.cloudflare.com;
    connect-src 'self' https://ops-gateway.grabem-holdem-nuts-right.workers.dev https://challenges.cloudflare.com;
    form-action 'self';
    worker-src 'self';
    script-src 'self' https://challenges.cloudflare.com 'nonce-ops-inline-asset';
    upgrade-insecure-requests;">

<meta http-equiv="Strict-Transport-Security" content="max-age=31536000; includeSubDomains; preload">
<meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
<meta http-equiv="Permissions-Policy" content="camera=(), microphone=(), geolocation=(), payment=(), interest-cohort=()">
<meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
<meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">

<style>
:root {
  --clr-primary:#00c4ff;
  --clr-accent:#ff3bdb;
  --clr-bg:#ffffff;
  --clr-bg-dark:#121212;
  --clr-tx:#333333;
  --clr-tx-dark:#f0f0f0;
}
body {
  margin:0; display:flex; align-items:center; justify-content:center;
  height:100vh; font-family:'Segoe UI',Arial,sans-serif;
  background:var(--clr-bg); color:var(--clr-tx); transition:background .3s,color .3s;
}
body.dark { --clr-bg:var(--clr-bg-dark); --clr-tx:var(--clr-tx-dark); }

#chatbot-container {
  width:300px; height:540px; background:#251541;
  border:2px solid var(--clr-accent); border-radius:18px; box-shadow:0 8px 32px #0006;
  display:flex; flex-direction:column; overflow:hidden;
}
#chatbot-header {
  display:flex; justify-content:center; align-items:center; gap:.5rem;
  background:linear-gradient(135deg,var(--clr-primary) 0%,var(--clr-accent) 100%);
  color:#fff; font-weight:600; font-size:1.1rem; padding:.75rem 1rem;
}
.ctrl-group { display:flex; align-items:center; gap:.35rem; flex-wrap:wrap; }
.ctrl {
  cursor:pointer; font-size:.75rem; font-weight:600; user-select:none; opacity:.9; color:#fff;
  background:#321b53; border:1px solid #fff3; border-radius:6px; padding:.25rem .55rem;
  transition:background .2s, color .2s, opacity .2s, box-shadow .2s;
}
.ctrl:hover { opacity:1; background:#3d2264; }
.ctrl.active { background:#fff; color:#321b53; opacity:1; box-shadow:0 0 0 1px #fff4; }

.icon { width:1em; height:1em; display:inline-block; vertical-align:-0.15em; fill:currentColor; }

#chat-log {
  flex:1; overflow-y:auto; padding:1rem; background:#1b0e2d; color:#eee; font-size:.94rem;
}
.chat-msg { margin:.5rem 0; max-width:90%; }
.user { margin-left:auto; background:var(--clr-primary); color:#000; padding:.5rem .7rem; border-radius:14px 14px 0 14px; }
.bot  { margin-right:auto; background:#321b53; color:#fff; padding:.5rem .7rem; border-radius:14px 14px 14px 0; }

#chatbot-form-container { background:#220f3a; border-top:1px solid var(--clr-accent); padding:.55rem .7rem .75rem; color:#fff; }
#control-row { display:flex; justify-content:flex-start; margin-bottom:.55rem; }
#chatbot-input-row { display:flex; flex-direction:column; gap:.6rem; }

#listenCtrl {
  background:#ffb703; border:none; color:#1b0e2d; font-weight:700;
  padding:.45rem .65rem; border-radius:8px; cursor:pointer; display:flex; align-items:center; justify-content:center;
  transition:transform .2s, box-shadow .2s;
}
#listenCtrl .btn-label { margin-left:.35rem; font-weight:700; }
#listenCtrl.active { box-shadow:0 0 0 2px #fff3; transform:scale(1.02); }

#chatbot-input { flex:1; background:transparent; border:none; color:#fff; font-size:.95rem; padding:.55rem .6rem; }
#chatbot-input::placeholder { color:#bfbfbf; }

#chatbot-send {
  display:flex; align-items:center; gap:6px; background:var(--clr-accent); border:none; color:#fff;
  font-weight:600; padding:.5rem .9rem; border-radius:8px; cursor:pointer; transition:.3s;
  align-self:flex-end;
}
#chatbot-send .icon { transition:transform .3s; }
#chatbot-send:hover .icon { transform:rotate(-45deg); }

#voice-status {
  margin:0.25rem 0 0.35rem;
  font-size:.83rem;
  color:#f5f7fb;
  opacity:.9;
  min-height:1.2em;
}

#turnstile-container { display:flex; justify-content:flex-end; }

/* Honeypots: visually hidden, not display:none */
.hp-wrap{
  position:absolute !important;
  left:-9999px !important;
  top:auto !important;
  width:1px !important;
  height:1px !important;
  overflow:hidden !important;
  opacity:0 !important;
}
</style>

<script src="https://challenges.cloudflare.com/turnstile/v0/api.js" defer></script>
</head>
<body>

<div id="chatbot-container" role="dialog" aria-modal="true">
  <div id="chatbot-header">
    <span id="title" data-en="OPS Online Support" data-es="Soporte en línea OPS">OPS Online Support</span>
  </div>

  <div id="chat-log" aria-live="polite"></div>

  <div id="chatbot-form-container">
    <div id="control-row" class="ctrl-group" aria-label="Language, theme, and speech controls">
      <button type="button" id="langCtrl" class="ctrl"
        aria-label="Toggle language" data-en-label="Toggle language" data-es-label="Cambiar idioma">EN</button>
      <button type="button" id="themeCtrl" class="ctrl">Dark</button>
      <button type="button" id="speechToggle" class="ctrl" data-en="Speech" data-es="Voz">Speech</button>

      <button id="listenCtrl" type="button" aria-label="Start voice input"
        data-en-label="Start voice input" data-es-label="Comenzar voz">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M12 14a3 3 0 0 0 3-3V6a3 3 0 1 0-6 0v5a3 3 0 0 0 3 3zm5-3a5 5 0 0 1-10 0H5a7 7 0 0 0 14 0h-2zM11 19h2v3h-2z"/>
        </svg>
        <span class="btn-label" data-en="Speak" data-es="Hablar">Speak</span>
      </button>
    </div>

    <div id="voice-status" role="status" aria-live="polite"></div>

    <form id="chatbot-input-row" autocomplete="off">
      <input id="chatbot-input" type="text" placeholder="Type your message..." required maxlength="256"
        data-en-ph="Type your message..." data-es-ph="Escriba su mensaje...">

      <!-- Honeypots -->
      <div class="hp-wrap" aria-hidden="true">
        <label>email<input id="hp_email" name="hp_email" type="text" autocomplete="off"></label>
        <label>website<input id="hp_website" name="hp_website" type="text" autocomplete="off"></label>
      </div>

      <div id="turnstile-container">
        <div id="turnstile-widget" class="cf-turnstile"
          data-sitekey="0x4AAAAAACCemZgiIexxcpTR"
          data-callback="opsTurnstileCallback"
          data-expired-callback="opsTurnstileExpired"
          data-error-callback="opsTurnstileErrored"></div>
      </div>

      <button id="chatbot-send" type="submit" aria-label="Send">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M2 21l20-9L2 3v7l14 2L2 14v7z"/>
        </svg>
      </button>
    </form>
  </div>
</div>

<script nonce="ops-inline-asset">
(() => {
  const qs  = s => document.querySelector(s);
  const qsa = s => [...document.querySelectorAll(s)];

  const ASSET_ID = "CAFF600A21B457E5D909FD887AF48018B3CBFDDF6F9746E56238B23AF061F9E2";

  // === Accept BOTH sites (GitHub Pages path + chattia.io root) ===
  const AUTH_RULES = [
    { origin: "https://chattiavato-a11y.github.io", pathPrefix: "/ops-online-support/" },
    { origin: "https://www.chattia.io",            pathPrefix: "/" }
  ];

  function isFullyAuthorized() {
    const o = self.origin;
    const p = self.location.pathname || "/";
    return AUTH_RULES.some(r => (o === r.origin) && p.startsWith(r.pathPrefix));
  }

  const API_URL = new URL("https://ops-gateway.grabem-holdem-nuts-right.workers.dev/api/ops-online-chat");

  const langCtrl     = qs('#langCtrl');
  const transNodes   = qsa('[data-en]');
  const phNodes      = qsa('[data-en-ph]');
  const ariaNodes    = qsa('[data-en-label]');

  const themeCtrl     = qs('#themeCtrl');
  const speechToggle  = qs('#speechToggle');
  const listenCtrl    = qs('#listenCtrl');

  const voiceStatus   = qs('#voice-status');

  const log   = qs('#chat-log');
  const form  = qs('#chatbot-input-row');
  const input = qs('#chatbot-input');
  const turnstileWidget = qs('#turnstile-widget');

  const hpEmail = qs('#hp_email');
  const hpWebsite = qs('#hp_website');

  let turnstileToken = '';
  let showedAuthWarning = false;
  let showedTurnstileDown = false;

  function addMsg(txt, cls) {
    const div = document.createElement('div');
    div.className = 'chat-msg ' + cls;
    div.textContent = txt;
    log.appendChild(div);
    log.scrollTop = log.scrollHeight;
    return div;
  }

  function setVoiceStatus(enText, esText) {
    if (!voiceStatus) return;
    voiceStatus.textContent = (currentLang === 'es') ? (esText || enText) : enText;
  }

  function showAuthWarningOnce() {
    if (showedAuthWarning) return;
    showedAuthWarning = true;
    addMsg(
      (currentLang === 'es')
        ? 'Este asistente solo acepta mensajes desde los sitios autorizados.'
        : 'This assistant only accepts messages from the authorized sites.',
      'bot'
    );
  }

  window.opsTurnstileCallback = (token) => {
    turnstileToken = (typeof token === 'string') ? token : '';
  };
  window.opsTurnstileExpired = () => { turnstileToken = ''; };
  window.opsTurnstileErrored = () => { turnstileToken = ''; };

  function getTurnstileToken() {
    if (turnstileToken) return turnstileToken;
    if (window.turnstile && typeof window.turnstile.getResponse === 'function') {
      try {
        const resp = window.turnstile.getResponse(turnstileWidget);
        if (resp) { turnstileToken = resp; return resp; }
      } catch {}
      try {
        const resp = window.turnstile.getResponse();
        if (resp) { turnstileToken = resp; return resp; }
      } catch {}
    }
    return '';
  }

  function resetTurnstile() {
    turnstileToken = '';
    if (window.turnstile && typeof window.turnstile.reset === 'function') {
      try { window.turnstile.reset(turnstileWidget); return; } catch {}
      try { window.turnstile.reset(); } catch {}
    }
  }

  // Auto-fallback when Turnstile is unavailable (secure behavior = disable sends)
  function turnstileUnavailableOnce() {
    if (showedTurnstileDown) return;
    showedTurnstileDown = true;
    addMsg(
      (currentLang === 'es')
        ? 'La verificación de seguridad no está disponible ahora. Intenta de nuevo en unos segundos.'
        : 'Security verification is unavailable right now. Try again in a few seconds.',
      'bot'
    );
  }

  const PREF_KEY = 'ops-chat-preferences';
  function loadPrefs() { try { const raw = localStorage.getItem(PREF_KEY); return raw ? JSON.parse(raw) : {}; } catch { return {}; } }
  function savePrefs(next) { try { localStorage.setItem(PREF_KEY, JSON.stringify(next || {})); } catch {} }

  const prefs = loadPrefs();
  let currentLang = (prefs.lang === 'es') ? 'es' : 'en';
  if (!prefs.lang) currentLang = document.documentElement.lang === 'es' ? 'es' : 'en';
  let currentTheme = prefs.theme === 'dark' ? 'dark' : 'light';

  const synth = 'speechSynthesis' in window ? window.speechSynthesis : null;
  const Recognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  const recognition = Recognition ? new Recognition() : null;

  const speechSupported = !!synth;
  const recognitionSupported = !!recognition;

  let listening = false;
  let speechEnabled = false;

  function normalizeUserText(s) {
    let out = String(s || '');
    out = out.replace(/[\u0000-\u001F\u007F]/g, ' ');
    out = out.replace(/\s+/g, ' ').trim();
    if (out.length > 256) out = out.slice(0, 256);
    return out;
  }

  function cleanForSpeech(s) {
    let out = String(s || '');
    out = out.replace(/`{3}[\s\S]*?`{3}/g, ' ');
    out = out.replace(/`([^`]+)`/g, '$1');
    out = out.replace(/[*_~]+/g, '');
    out = out.replace(/^-\s+/gm, '');
    out = out.replace(/\s+/g, ' ').trim();
    return out;
  }

  function looksSuspicious(s) {
    const t = String(s || '').toLowerCase();
    const bad = [
      "<script", "</script", "javascript:",
      "<img", "onerror", "onload",
      "<iframe", "<object", "<embed",
      "<svg", "<link", "<meta", "<style",
      "document.cookie",
      "onmouseover", "onmouseenter",
      "<form", "<input", "<textarea"
    ];
    return bad.some(p => t.includes(p));
  }

  function updateSpeechToggleUI() {
    speechToggle.classList.toggle('active', speechEnabled);
    speechToggle.setAttribute('aria-pressed', speechEnabled ? 'true' : 'false');
  }
  function updateListenUI() {
    listenCtrl.classList.toggle('active', listening);
    listenCtrl.setAttribute('aria-pressed', listening ? 'true' : 'false');
  }

  function persistPrefs() { savePrefs({ lang: currentLang, theme: currentTheme }); }

  function setLanguage(lang) {
    const toES = lang === 'es';
    currentLang = toES ? 'es' : 'en';
    document.documentElement.lang = currentLang;

    langCtrl.textContent = toES ? 'ES' : 'EN';
    langCtrl.setAttribute('aria-pressed', toES ? 'true' : 'false');
    langCtrl.classList.toggle('active', toES);

    transNodes.forEach(node => { node.textContent = toES ? node.dataset.es : node.dataset.en; });
    phNodes.forEach(node => { node.placeholder = toES ? node.dataset.esPh : node.dataset.enPh; });
    ariaNodes.forEach(node => { node.setAttribute('aria-label', toES ? node.dataset.esLabel : node.dataset.enLabel); });

    if (recognition) recognition.lang = toES ? 'es-ES' : 'en-US';
    persistPrefs();
    setVoiceStatus('', '');
  }
  langCtrl.addEventListener('click', () => setLanguage(currentLang === 'es' ? 'en' : 'es'));

  function setTheme(mode) {
    currentTheme = mode === 'dark' ? 'dark' : 'light';
    document.body.classList.toggle('dark', currentTheme === 'dark');
    themeCtrl.textContent = currentTheme === 'dark' ? 'Light' : 'Dark';
    themeCtrl.setAttribute('aria-pressed', currentTheme === 'dark' ? 'true' : 'false');
    persistPrefs();
  }
  themeCtrl.onclick = () => setTheme(currentTheme === 'dark' ? 'light' : 'dark');

  function getVoiceForLang(langCode) {
    if (!synth) return null;
    const voices = synth.getVoices();
    const want = langCode === 'es' ? ['es-', 'es_'] : ['en-', 'en_'];
    const preferred = voices
      .filter(v => want.some(p => (v.lang || '').toLowerCase().startsWith(p)))
      .sort((a,b)=>((b.localService?2:0)+(/google|microsoft|natural/i.test(b.name)?1:0))-((a.localService?2:0)+(/google|microsoft|natural/i.test(a.name)?1:0)));
    return preferred[0] || null;
  }

  function speak(text, langOverride) {
    if (!synth || !speechEnabled) return;
    const clean = cleanForSpeech(normalizeUserText(text));
    if (!clean) return;
    const langForReply = langOverride === 'es' ? 'es' : (langOverride === 'en' ? 'en' : currentLang);
    synth.cancel();
    const u = new SpeechSynthesisUtterance(clean);
    u.lang = langForReply === 'es' ? 'es-ES' : 'en-US';
    const v = getVoiceForLang(langForReply); if (v) u.voice = v;
    if (langForReply === 'en') { u.rate = 1.03; u.pitch = 1.02; }
    synth.speak(u);
  }
  if (synth) synth.onvoiceschanged = () => getVoiceForLang(currentLang);

  if (recognition) {
    recognition.continuous = false; recognition.interimResults = false;
    recognition.lang = currentLang === 'es' ? 'es-ES' : 'en-US';
    recognition.onstart = () => { listening = true; updateListenUI(); };
    recognition.onresult = e => {
      const transcript = e.results?.[0]?.[0]?.transcript || '';
      const cleaned = normalizeUserText(transcript);
      if (cleaned) {
        input.value = cleaned;
        input.focus();
        if (isFullyAuthorized()) {
          form.requestSubmit();
        } else {
          showAuthWarningOnce();
        }
      }
    };
    recognition.onerror = () => { listening = false; updateListenUI(); };
    recognition.onend   = () => { listening = false; updateListenUI(); };
  }

  function startListening(){
    if (!recognition) return;
    recognition.lang = currentLang==='es'?'es-ES':'en-US';
    listening=true;
    updateListenUI();
    recognition.start();
  }

  speechToggle.onclick = () => {
    if (!synth) { addMsg(currentLang==='es'?'La síntesis de voz no está disponible.':'Speech synthesis is not available.','bot'); return; }
    speechEnabled = !speechEnabled; updateSpeechToggleUI();
  };

  listenCtrl.onclick = () => {
    if (!recognition) { addMsg(currentLang==='es'?'Entrada por voz no disponible en este navegador.' : 'Voice input is not available in this browser.','bot'); return; }
    if (listening) { recognition.stop(); return; }
    startListening();
  };

  setLanguage(currentLang);
  setTheme(currentTheme);
  updateSpeechToggleUI();
  updateListenUI();

  form.onsubmit = async e => {
    e.preventDefault();

    const requestLang = currentLang;
    const msg = normalizeUserText(input.value);
    if (!msg) return;

    if (!isFullyAuthorized()) {
      showAuthWarningOnce();
      return;
    }

    if (looksSuspicious(msg)) {
      const warn = requestLang === 'es'
        ? 'Mensaje bloqueado por seguridad. Escribe sin etiquetas o scripts.'
        : 'Message blocked for security. Please write without tags or scripts.';
      addMsg(warn, 'bot'); speak(warn, requestLang); return;
    }

    // Honeypots
    const hp1 = normalizeUserText(hpEmail?.value || '');
    const hp2 = normalizeUserText(hpWebsite?.value || '');

    // Turnstile availability / token (session-aware reuse: DO NOT force reset after success)
    const activeTurnstileToken = getTurnstileToken();
    if (!activeTurnstileToken) {
      // Turnstile may still be initializing or unavailable
      if (!window.turnstile) {
        turnstileUnavailableOnce();
      } else {
        const warn = requestLang === 'es'
          ? 'Completa la verificación de seguridad para continuar.'
          : 'Please complete the security check to continue.';
        addMsg(warn, 'bot'); speak(warn, requestLang);
      }
      return;
    }

    addMsg(msg, 'user');
    input.value = '';

    const botDiv = addMsg('…', 'bot');

    try {
      const ctrl = new AbortController();
      const to = setTimeout(() => ctrl.abort(), 15000);

      const res = await fetch(API_URL.href, {
        method: 'POST',
        mode: 'cors',
        cache: 'no-store',
        credentials: 'omit',
        redirect: 'error',
        referrerPolicy: 'no-referrer',
        headers: {
          'Content-Type': 'application/json',
          'X-Ops-Asset-Id': ASSET_ID
        },
        body: JSON.stringify({
          message: msg,
          lang: requestLang,
          v: 1,
          turnstileToken: activeTurnstileToken,
          hp_email: hp1,
          hp_website: hp2
        }),
        signal: ctrl.signal
      });

      clearTimeout(to);

      const text = await res.text();
      let data = null; try { data = JSON.parse(text); } catch {}

      if (!res.ok) {
        const fallback = requestLang==='es' ? 'Error del gateway de OPS.' : 'OPS gateway error.';
        const errMsg = (data && (data.error || data.public_error)) ? (data.error || data.public_error) : (text || fallback);
        botDiv.textContent = errMsg;
        speak(errMsg, requestLang);

        // If Turnstile failed, reset ONLY then
        if (res.status === 403 && /turnstile/i.test(errMsg)) {
          resetTurnstile();
        }
        return;
      }

      if (!data || typeof data !== 'object') {
        const fallback = requestLang==='es' ? 'Respuesta no válida del gateway.' : 'Invalid response from gateway.';
        botDiv.textContent = fallback; speak(fallback, requestLang);
        return;
      }

      if (data.error || data.public_error) {
        const err = data.error || data.public_error;
        botDiv.textContent = err; speak(err, requestLang);

        if (res.status === 403 && /turnstile/i.test(err)) {
          resetTurnstile();
        }
        return;
      }

      const replyLang = data.lang === 'es' ? 'es' : requestLang;
      const reply = (typeof data.reply === 'string' && data.reply.trim())
        ? data.reply.trim()
        : (requestLang==='es' ? 'Sin respuesta.' : 'No reply.');
      botDiv.textContent = reply;
      speak(reply, replyLang);

      // IMPORTANT: no reset here (pre-clearance + reuse = clean UX)
    } catch {
      const fallback = requestLang==='es' ? 'No puedo conectar con el asistente OPS.' : 'Can’t reach OPS assistant.';
      botDiv.textContent = fallback; speak(fallback, requestLang);
    }
  };
})();
</script>
</body>
</html>
