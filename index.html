<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>OPS Online Support</title>

<meta http-equiv="Content-Security-Policy"
  content="default-src 'self';
    base-uri 'self';
    object-src 'none';
    style-src 'self' 'unsafe-inline';
    img-src 'self' data:;
    font-src 'self' data:;
    frame-src 'self' https://challenges.cloudflare.com;
    connect-src 'self' https://ops-gateway.grabem-holdem-nuts-right.workers.dev https://challenges.cloudflare.com;
    form-action 'self';
    worker-src 'self';
    script-src 'self' https://challenges.cloudflare.com 'nonce-ops-inline-asset';
    upgrade-insecure-requests;">

<meta http-equiv="Strict-Transport-Security" content="max-age=31536000; includeSubDomains; preload">
<meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
<meta http-equiv="Permissions-Policy" content="camera=(), microphone=(), geolocation=(), payment=(), interest-cohort=()">
<meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
<meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">

<style>
:root {
  --clr-primary:#00c4ff;
  --clr-accent:#ff3bdb;
  --clr-bg:#ffffff;
  --clr-bg-dark:#121212;
  --clr-tx:#333333;
  --clr-tx-dark:#f0f0f0;
}
body {
  margin:0; display:flex; align-items:center; justify-content:center;
  height:100vh; font-family:'Segoe UI',Arial,sans-serif;
  background:var(--clr-bg); color:var(--clr-tx); transition:background .3s,color .3s;
}
body.dark { --clr-bg:var(--clr-bg-dark); --clr-tx:var(--clr-tx-dark); }

#chatbot-container {
  width:300px; height:540px; background:#251541;
  border:2px solid var(--clr-accent); border-radius:18px; box-shadow:0 8px 32px #0006;
  display:flex; flex-direction:column; overflow:hidden;
}
#chatbot-header {
  display:flex; justify-content:center; align-items:center; gap:.5rem;
  background:linear-gradient(135deg,var(--clr-primary) 0%,var(--clr-accent) 100%);
  color:#fff; font-weight:600; font-size:1.1rem; padding:.75rem 1rem;
}
.ctrl-group { display:flex; align-items:center; gap:.35rem; flex-wrap:wrap; }
.ctrl {
  cursor:pointer; font-size:.75rem; font-weight:600; user-select:none; opacity:.9; color:#fff;
  background:#321b53; border:1px solid #fff3; border-radius:6px; padding:.25rem .55rem;
  transition:background .2s, color .2s, opacity .2s, box-shadow .2s;
}
.ctrl:hover { opacity:1; background:#3d2264; }
.ctrl.active { background:#fff; color:#321b53; opacity:1; box-shadow:0 0 0 1px #fff4; }

.icon { width:1em; height:1em; display:inline-block; vertical-align:-0.15em; fill:currentColor; }

#chat-log {
  flex:1; overflow-y:auto; padding:1rem; background:#1b0e2d; color:#eee; font-size:.94rem;
}
.chat-msg { margin:.5rem 0; max-width:90%; }
.user { margin-left:auto; background:var(--clr-primary); color:#000; padding:.5rem .7rem; border-radius:14px 14px 0 14px; }
.bot  { margin-right:auto; background:#321b53; color:#fff; padding:.5rem .7rem; border-radius:14px 14px 14px 0; }

#chatbot-form-container { background:#220f3a; border-top:1px solid var(--clr-accent); padding:.55rem .7rem .75rem; color:#fff; }
#control-row { display:flex; justify-content:flex-start; margin-bottom:.55rem; }
#chatbot-input-row { display:flex; flex-direction:column; gap:.6rem; }

#listenCtrl {
  background:#ffb703; border:none; color:#1b0e2d; font-weight:700;
  padding:.45rem .65rem; border-radius:8px; cursor:pointer; display:flex; align-items:center; justify-content:center;
  transition:transform .2s, box-shadow .2s;
}
#listenCtrl .btn-label { margin-left:.35rem; font-weight:700; }
#listenCtrl.active { box-shadow:0 0 0 2px #fff3; transform:scale(1.02); }

#chatbot-input { flex:1; background:transparent; border:none; color:#fff; font-size:.95rem; padding:.55rem .6rem; }
#chatbot-input::placeholder { color:#bfbfbf; }

#chatbot-send {
  display:flex; align-items:center; gap:6px; background:var(--clr-accent); border:none; color:#fff;
  font-weight:600; padding:.5rem .9rem; border-radius:8px; cursor:pointer; transition:.3s;
}
#chatbot-send .icon { transition:transform .3s; }
#chatbot-send:hover .icon { transform:rotate(-45deg); }

#voice-status {
  margin:0.25rem 0 0.35rem;
  font-size:.83rem;
  color:#f5f7fb;
  opacity:.9;
  min-height:1.2em;
}

#turnstile-container { display:flex; justify-content:flex-end; }
#chatbot-send { align-self:flex-end; }

/* Honeypot: visually hidden but still in DOM flow */
.hp-field {
  position:absolute;
  left:-10000px;
  top:auto;
  width:1px; height:1px;
  overflow:hidden;
  opacity:0.01;
  pointer-events:none;
}
</style>

<script src="https://challenges.cloudflare.com/turnstile/v0/api.js" defer></script>
</head>

<body>
<div id="chatbot-container" role="dialog" aria-modal="true">
  <div id="chatbot-header">
    <span id="title" data-en="OPS Online Support" data-es="Soporte en línea OPS">OPS Online Support</span>
  </div>

  <div id="chat-log" aria-live="polite"></div>

  <div id="chatbot-form-container">
    <div id="control-row" class="ctrl-group" aria-label="Language, theme, and speech controls">
      <button type="button" id="langCtrl" class="ctrl"
        aria-label="Toggle language" data-en-label="Toggle language" data-es-label="Cambiar idioma">EN</button>
      <button type="button" id="themeCtrl" class="ctrl">Dark</button>
      <button type="button" id="speechToggle" class="ctrl" data-en="Speech" data-es="Voz">Speech</button>

      <button id="listenCtrl" type="button" aria-label="Start voice input"
        data-en-label="Start voice input" data-es-label="Comenzar voz">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M12 14a3 3 0 0 0 3-3V6a3 3 0 1 0-6 0v5a3 3 0 0 0 3 3zm5-3a5 5 0 0 1-10 0H5a7 7 0 0 0 14 0h-2zM11 19h2v3h-2z"/>
        </svg>
        <span class="btn-label" data-en="Speak" data-es="Hablar">Speak</span>
      </button>
    </div>

    <div id="voice-status" role="status" aria-live="polite"></div>

    <form id="chatbot-input-row" autocomplete="off">
      <!-- Honeypots -->
      <input class="hp-field" type="text" name="hp_email" id="hp_email" autocomplete="off" tabindex="-1" aria-hidden="true">
      <input class="hp-field" type="text" name="hp_website" id="hp_website" autocomplete="off" tabindex="-1" aria-hidden="true">

      <input id="chatbot-input" type="text" placeholder="Type your message..." required maxlength="256"
        data-en-ph="Type your message..." data-es-ph="Escriba su mensaje...">

      <div id="turnstile-container">
        <div id="turnstile-widget" class="cf-turnstile"
          data-sitekey="0x4AAAAAACCemZgiIexxcpTR"
          data-callback="opsTurnstileCallback"
          data-expired-callback="opsTurnstileExpired"
          data-error-callback="opsTurnstileErrored"></div>
      </div>

      <button id="chatbot-send" type="submit" aria-label="Send">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M2 21l20-9L2 3v7l14 2L2 14v7z"/>
        </svg>
      </button>
    </form>
  </div>
</div>

<script nonce="ops-inline-asset">
(() => {
  const qs  = s => document.querySelector(s);
  const qsa = s => [...document.querySelectorAll(s)];

  /* ===== Fixed asset ID header ===== */
  const ASSET_ID = "CAFF600A21B457E5D909FD887AF48018B3CBFDDF6F9746E56238B23AF061F9E2";

  /* ===== Allowed hosts + path policy ===== */
  const ALLOWED_HOSTS = new Set([
    "chattiavato-a11y.github.io",
    "www.chattia.io"
  ]);

  function isAuthorizedClientLocation() {
    try {
      const host = self.location.host;
      if (!ALLOWED_HOSTS.has(host)) return false;

      // If on GitHub Pages, require the repo path prefix
      if (host === "chattiavato-a11y.github.io") {
        return self.location.pathname.startsWith("/ops-online-support/");
      }

      // If on chattia.io, allow root and any path
      if (host === "www.chattia.io") {
        return self.location.pathname.startsWith("/");
      }

      return false;
    } catch {
      return false;
    }
  }

  const fullyAuthorized = isAuthorizedClientLocation();

  /* ===== Gateway endpoint ===== */
  const API_URL = new URL("https://ops-gateway.grabem-holdem-nuts-right.workers.dev/api/ops-online-chat");

  /* ===== UI refs ===== */
  const langCtrl     = qs('#langCtrl');
  const transNodes   = qsa('[data-en]');
  const phNodes      = qsa('[data-en-ph]');
  const ariaNodes    = qsa('[data-en-label]');
  const themeCtrl     = qs('#themeCtrl');
  const speechToggle  = qs('#speechToggle');
  const listenCtrl    = qs('#listenCtrl');
  const voiceStatus   = qs('#voice-status');
  const log   = qs('#chat-log');
  const form  = qs('#chatbot-input-row');
  const input = qs('#chatbot-input');
  const turnstileWidget = qs('#turnstile-widget');
  const hpEmail = qs('#hp_email');
  const hpWebsite = qs('#hp_website');

  /* ===== One-time auth warning ===== */
  let showedAuthWarning = false;
  function addMsg(txt, cls) {
    const div = document.createElement('div');
    div.className = 'chat-msg ' + cls;
    div.textContent = txt;
    log.appendChild(div);
    log.scrollTop = log.scrollHeight;
    return div;
  }
  function showAuthWarningOnce(lang) {
    if (showedAuthWarning) return;
    showedAuthWarning = true;
    const msg = (lang === 'es')
      ? 'Este asistente solo acepta mensajes desde los sitios autorizados.'
      : 'This assistant only accepts messages from authorized sites.';
    addMsg(msg, 'bot');
  }
  function setVoiceStatus(enText, esText) {
    if (!voiceStatus) return;
    voiceStatus.textContent = (currentLang === 'es') ? (esText || enText) : enText;
  }

  /* ===== Turnstile token handling (NO forced reset on success) ===== */
  let turnstileToken = '';
  window.opsTurnstileCallback = (token) => { turnstileToken = (typeof token === 'string') ? token : ''; };
  window.opsTurnstileExpired = () => { turnstileToken = ''; };
  window.opsTurnstileErrored = () => { turnstileToken = ''; };

  function getTurnstileToken() {
    if (turnstileToken) return turnstileToken;
    if (window.turnstile && typeof window.turnstile.getResponse === 'function') {
      try {
        const resp = window.turnstile.getResponse(turnstileWidget);
        if (resp) { turnstileToken = resp; return resp; }
      } catch {}
      try {
        const resp = window.turnstile.getResponse();
        if (resp) { turnstileToken = resp; return resp; }
      } catch {}
    }
    return '';
  }

  function resetTurnstileOnlyIfNeeded() {
    turnstileToken = '';
    if (window.turnstile && typeof window.turnstile.reset === 'function') {
      try { window.turnstile.reset(turnstileWidget); return; } catch {}
      try { window.turnstile.reset(); } catch {}
    }
  }

  /* ===== Language + theme preferences ===== */
  const PREF_KEY = 'ops-chat-preferences';
  function loadPrefs() { try { const raw = localStorage.getItem(PREF_KEY); return raw ? JSON.parse(raw) : {}; } catch { return {}; } }
  function savePrefs(next) { try { localStorage.setItem(PREF_KEY, JSON.stringify(next || {})); } catch {} }
  const prefs = loadPrefs();

  let currentLang = (prefs.lang === 'es') ? 'es' : 'en';
  if (!prefs.lang) currentLang = document.documentElement.lang === 'es' ? 'es' : 'en';
  let currentTheme = prefs.theme === 'dark' ? 'dark' : 'light';

  const synth = 'speechSynthesis' in window ? window.speechSynthesis : null;
  const Recognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  const recognition = Recognition ? new Recognition() : null;
  const speechSupported = !!synth;
  const recognitionSupported = !!recognition;

  let listening = false;
  let speechEnabled = false;

  function normalizeUserText(s) {
    let out = String(s || '');
    out = out.replace(/[\u0000-\u001F\u007F]/g, ' ');
    out = out.replace(/\s+/g, ' ').trim();
    if (out.length > 256) out = out.slice(0, 256);
    return out;
  }
  function cleanForSpeech(s) {
    let out = String(s || '');
    out = out.replace(/`{3}[\s\S]*?`{3}/g, ' ');
    out = out.replace(/`([^`]+)`/g, '$1');
    out = out.replace(/[*_~]+/g, '');
    out = out.replace(/^-\s+/gm, '');
    out = out.replace(/\s+/g, ' ').trim();
    return out;
  }
  function looksSuspicious(s) {
    const t = String(s || '').toLowerCase();
    const bad = [
      "<script", "</script", "javascript:",
      "<img", "onerror", "onload",
      "<iframe", "<object", "<embed",
      "<svg", "<link", "<meta", "<style",
      "document.cookie",
      "onmouseover", "onmouseenter",
      "<form", "<input", "<textarea"
    ];
    return bad.some(p => t.includes(p));
  }

  function updateSpeechToggleUI() {
    speechToggle.classList.toggle('active', speechEnabled);
    speechToggle.setAttribute('aria-pressed', speechEnabled ? 'true' : 'false');
  }
  function updateListenUI() {
    listenCtrl.classList.toggle('active', listening);
    listenCtrl.setAttribute('aria-pressed', listening ? 'true' : 'false');
  }

  function persistPrefs() { savePrefs({ lang: currentLang, theme: currentTheme }); }

  function setLanguage(lang) {
    const toES = lang === 'es';
    currentLang = toES ? 'es' : 'en';
    document.documentElement.lang = currentLang;

    langCtrl.textContent = toES ? 'ES' : 'EN';
    langCtrl.setAttribute('aria-pressed', toES ? 'true' : 'false');
    langCtrl.classList.toggle('active', toES);

    transNodes.forEach(node => { node.textContent = toES ? node.dataset.es : node.dataset.en; });
    phNodes.forEach(node => { node.placeholder = toES ? node.dataset.esPh : node.dataset.enPh; });
    ariaNodes.forEach(node => { node.setAttribute('aria-label', toES ? node.dataset.esLabel : node.dataset.enLabel); });

    if (recognition) recognition.lang = toES ? 'es-ES' : 'en-US';
    persistPrefs();
  }
  langCtrl.addEventListener('click', () => setLanguage(currentLang === 'es' ? 'en' : 'es'));

  function setTheme(mode) {
    currentTheme = mode === 'dark' ? 'dark' : 'light';
    document.body.classList.toggle('dark', currentTheme === 'dark');
    themeCtrl.textContent = currentTheme === 'dark' ? 'Light' : 'Dark';
    themeCtrl.setAttribute('aria-pressed', currentTheme === 'dark' ? 'true' : 'false');
    persistPrefs();
  }
  themeCtrl.onclick = () => setTheme(currentTheme === 'dark' ? 'light' : 'dark');

  function getVoiceForLang(langCode) {
    if (!synth) return null;
    const voices = synth.getVoices();
    const want = langCode === 'es' ? ['es-', 'es_'] : ['en-', 'en_'];
    const preferred = voices
      .filter(v => want.some(p => (v.lang || '').toLowerCase().startsWith(p)))
      .sort((a,b)=>((b.localService?2:0)+(/google|microsoft|natural/i.test(b.name)?1:0))-((a.localService?2:0)+(/google|microsoft|natural/i.test(a.name)?1:0)));
    return preferred[0] || null;
  }
  function speak(text, langOverride) {
    if (!synth || !speechEnabled) return;
    const clean = cleanForSpeech(normalizeUserText(text));
    if (!clean) return;
    const langForReply = langOverride === 'es' ? 'es' : (langOverride === 'en' ? 'en' : currentLang);
    synth.cancel();
    const u = new SpeechSynthesisUtterance(clean);
    u.lang = langForReply === 'es' ? 'es-ES' : 'en-US';
    const v = getVoiceForLang(langForReply); if (v) u.voice = v;
    if (langForReply === 'en') { u.rate = 1.03; u.pitch = 1.02; }
    synth.speak(u);
    u.onend = () => {};
  }
  if (synth) synth.onvoiceschanged = () => getVoiceForLang(currentLang);

  if (recognition) {
    recognition.continuous = false;
    recognition.interimResults = false;
    recognition.lang = currentLang === 'es' ? 'es-ES' : 'en-US';
    recognition.onstart = () => { listening = true; updateListenUI(); };
    recognition.onresult = e => {
      const transcript = e.results?.[0]?.[0]?.transcript || '';
      const cleaned = normalizeUserText(transcript);
      if (cleaned) {
        input.value = cleaned;
        input.focus();
        if (fullyAuthorized) form.requestSubmit();
        else showAuthWarningOnce(currentLang);
      }
    };
    recognition.onerror = () => { listening = false; updateListenUI(); };
    recognition.onend   = () => { listening = false; updateListenUI(); };
  }

  speechToggle.onclick = () => {
    if (!synth) { addMsg(currentLang==='es'?'La síntesis de voz no está disponible.':'Speech synthesis is not available.','bot'); return; }
    speechEnabled = !speechEnabled;
    updateSpeechToggleUI();
  };

  listenCtrl.onclick = () => {
    if (!recognition) { addMsg(currentLang==='es'?'Entrada por voz no disponible en este navegador.' : 'Voice input is not available in this browser.','bot'); return; }
    if (listening) { recognition.stop(); return; }
    if (!fullyAuthorized) { showAuthWarningOnce(currentLang); return; }
    recognition.lang = currentLang==='es'?'es-ES':'en-US';
    recognition.start();
  };

  setLanguage(currentLang);
  setTheme(currentTheme);
  updateSpeechToggleUI();
  updateListenUI();

  if (!fullyAuthorized) showAuthWarningOnce(currentLang);

  form.onsubmit = async (e) => {
    e.preventDefault();

    const requestLang = currentLang;
    const msg = normalizeUserText(input.value);
    if (!msg) return;

    if (!fullyAuthorized) {
      showAuthWarningOnce(requestLang);
      return;
    }

    if (looksSuspicious(msg)) {
      const warn = requestLang === 'es'
        ? 'Mensaje bloqueado por seguridad. Por favor escribe sin etiquetas o scripts.'
        : 'Message blocked for security. Please write without tags or scripts.';
      addMsg(warn, 'bot'); speak(warn, requestLang); return;
    }

    const hp_email = normalizeUserText(hpEmail?.value || '');
    const hp_website = normalizeUserText(hpWebsite?.value || '');

    const token = getTurnstileToken();
    if (!token) {
      const warn = requestLang === 'es'
        ? 'La verificación de seguridad no está lista. Espera un momento y vuelve a intentar.'
        : 'Security verification is not ready. Wait a moment and try again.';
      addMsg(warn, 'bot'); speak(warn, requestLang); return;
    }

    addMsg(msg, 'user');
    input.value = '';
    const botDiv = addMsg('…', 'bot');

    try {
      const ctrl = new AbortController();
      const to = setTimeout(() => ctrl.abort(), 15000);

      const res = await fetch(API_URL.href, {
        method: 'POST',
        mode: 'cors',
        cache: 'no-store',
        credentials: 'omit',
        redirect: 'error',
        referrerPolicy: 'no-referrer',
        headers: {
          'Content-Type': 'application/json',
          'X-Ops-Asset-Id': ASSET_ID
        },
        body: JSON.stringify({
          message: msg,
          lang: requestLang,
          v: 1,
          turnstileToken: token,
          hp_email,
          hp_website
        }),
        signal: ctrl.signal
      });

      clearTimeout(to);

      const raw = await res.text();
      let data = null; try { data = JSON.parse(raw); } catch {}

      if (!res.ok) {
        const fallback = requestLang==='es' ? 'Error del gateway de OPS.' : 'OPS gateway error.';
        const errMsg = (data && (data.error || data.public_error)) ? (data.error || data.public_error) : (raw || fallback);

        botDiv.textContent = errMsg;
        speak(errMsg, requestLang);

        // Only reset Turnstile when verification actually failed
        if (String(errMsg).toLowerCase().includes('turnstile')) {
          resetTurnstileOnlyIfNeeded();
        }
        return;
      }

      const replyLang = (data && data.lang === 'es') ? 'es' : requestLang;
      const reply = (data && typeof data.reply === 'string' && data.reply.trim())
        ? data.reply.trim()
        : (requestLang==='es' ? 'Sin respuesta.' : 'No reply.');

      botDiv.textContent = reply;
      speak(reply, replyLang);

      // IMPORTANT: no forced reset on success (pre-clearance + managed handles UX)
    } catch {
      const fallback = requestLang==='es'
        ? 'Error: no puedo conectar con el asistente OPS.'
        : 'Error: can’t reach OPS assistant.';
      botDiv.textContent = fallback;
      speak(fallback, requestLang);
    }
  };
})();
</script>
</body>
</html>

